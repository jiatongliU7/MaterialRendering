<!doctype html>
<html>

<head>
    <title>CS112 Final Project - Advanced Shading</title>
    <meta charset="utf-8">
    <link href="css/main.css" rel="stylesheet">
    <link href="css/spectrum.css" rel="stylesheet">

    <!-- Useful 3rd party libraries -->
    <script type="text/javascript" src="js/jquery-1.12.2.min.js"></script>
    <script type="text/javascript" src="js/spectrum.js"></script>
    <script type="text/javascript" src="js/glMatrix-0.9.5.js"></script>
    <script type="text/javascript" src="js/webgl-obj-loader.js"></script>

    <!-- Shader initialization utils -->
    <script type="text/javascript" src="js/shader-utils.js"></script>

    <!-- WebGL debugging utils -->
    <script type="text/javascript" src="js/webgl-debug.js"></script>
    <script type="text/javascript" src="js/debug-utils.js"></script>

    <!-- Model data -->
    <script type="text/javascript" src="meshes/teapot_obj.js"></script>
    <script type="text/javascript" src="meshes/bunny_obj.js"></script>
    <script type="text/javascript" src="meshes/rock_obj.js"></script>
    <script type="text/javascript" src="meshes/sphere_obj.js"></script>

    <!-- WebGL functions -->
    <script type="text/javascript" src="main_webgl.js"></script>

    <!-- Other javascript functions -->
    <script type="text/javascript" src="main.js"></script>

    <!-- Simple vertex shader for drawing the light source as a point -->
    <script id="shader-vs-light" type="x-shader/x-vertex">
        uniform mat4 uPMatrix;
        attribute vec3 aVertexPosition;

        void main(void) {
            gl_PointSize = 10.0;
            gl_Position = uPMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>

    <!-- Common vertex shader for all reflectance models -->
    <script id="shader-vs" type="x-shader/x-vertex">
        uniform mat4 uMVMatrix;             // Model-view matrix
        uniform mat4 uPMatrix;              // Projection matrix
        uniform mat4 uNMatrix;              // Normal matrix

        attribute vec3 aVertexPosition;     // Vertex position in object space
        attribute vec3 aVertexNormal;       // Vertex normal in object space

        varying vec3 vPosition;             // Vertex position (camera space)
        varying vec3 vNormal;               // Vertex normal (camera space)

        void main(void) {
            vec4 camSpacePosition = uMVMatrix * vec4(aVertexPosition, 1.0);
            vPosition = vec3(camSpacePosition);

            gl_Position = uPMatrix * camSpacePosition;

            vec4 camSpaceNormal = uNMatrix * vec4(aVertexNormal, 0.0);
            vNormal = vec3(camSpaceNormal);
        }
    </script>

    <!-- Fragment shader: light draing -->
    <script id="shader-fs-light" type="x-shader/x-fragment">
        precision mediump float;

        void main(void) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
        }
    </script>

    <!-- Cubemap vertex shader -->
    <script id="shader-vs-cubemap" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        varying vec3 vTexCoord;

        void main() {
            vTexCoord = aVertexPosition;
            gl_Position = vec4(aVertexPosition, 1.0);
        }

    </script>

    <!-- Cubemap fragment shader -->
    <script id="shader-fs-cubemap" type="x-shader/x-fragment">
        precision mediump float;
        varying vec3 vTexCoord;
        uniform samplerCube uEnvironmentMap;

        void main() {
            gl_FragColor = textureCube(uEnvironmentMap, normalize(vTexCoord));
        }
    </script>

    <!-- Fragment shader: environment map only (option 8) -->
    <script id="shader-fs-env" type="x-shader/x-fragment">
        precision mediump float;
        uniform samplerCube uEnvironmentMap;

        varying vec3 vPosition;
        varying vec3 vNormal;

        void main(void) {
            // Reflect environment map
            vec3 reflectedDir = reflect(normalize(vPosition), normalize(vNormal));
            gl_FragColor = textureCube(uEnvironmentMap, reflectedDir);
        }
    </script>

    <!-- Fragment shader: metal (option 9) -->
    <script id="shader-fs-metal" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec3 uLightPos;             
        uniform float uLightPower;         
        uniform vec3 uDiffuseColor;         
        uniform vec3 uSpecularColor;        
        uniform float uExponent;            
        uniform float uAmbient;             
        uniform samplerCube uEnvironmentMap;
        uniform bool useEnvironmentMap;      
        
        varying vec3 vPosition;              
        varying vec3 vNormal;                
        
        void main(void) {
            vec3 lightDirection = uLightPos - vPosition;
            float lightDistance = length(lightDirection);
            vec3 normalizedLightDir = normalize(lightDirection);
            vec3 normalizedNormal = normalize(vNormal);
            vec3 viewDirection = normalize(-vPosition);
            
            float I = uLightPower / (1.0 + 0.1 * lightDistance * lightDistance);
        
            float diffuse = max(dot(normalizedNormal, normalizedLightDir), 0.0);
            vec3 diffuseColor = uDiffuseColor * (I * diffuse * 0.2 + uAmbient); // 减弱漫反射
        
            vec3 reflectionDirection = reflect(-normalizedLightDir, normalizedNormal);
            float specular = 0.0;
            if (diffuse > 0.0) {
                specular = pow(max(dot(viewDirection, reflectionDirection), 0.0), uExponent);
            }
            vec3 specularColor = uSpecularColor * I * specular;
        
            vec3 envColor = vec3(0.0);
            if (useEnvironmentMap) {
                vec3 reflectedDir = reflect(-viewDirection, normalizedNormal);
                envColor = textureCube(uEnvironmentMap, reflectedDir).rgb;
            }
        
            float stripe = abs(sin(vPosition.x * 8.0));  // 减少密度 (8.0 -> 更宽条纹)
            stripe = smoothstep(0.3, 0.7, stripe);       // 扩大过渡范围 (0.3 和 0.7 控制模糊边界)
            
            // 控制条纹强度，让其不完全覆盖高光
            float stripeStrength = 0.5;   
            specularColor = mix(specularColor, specularColor * stripe, stripeStrength);

            vec3 fragColor = diffuseColor + specularColor + envColor * 0.6; // 调整环境反射强度
            gl_FragColor = vec4(fragColor, 1.0);
        }
    </script>
        
    
        

    <!-- Fragment shader: white -->
    <script id="shader-fs0" type="x-shader/x-fragment">
        precision mediump float;

        void main(void) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    </script>

    <!-- porcelain -->
    <script id="shader-fs1-1" type="x-shader/x-fragment">
            precision mediump float;
        
            uniform vec3 uLightPos;            
            uniform float uLightPower;         
            uniform vec3 uDiffuseColor;         
            uniform vec3 uSpecularColor;         
            uniform float uAmbient;             
            uniform samplerCube uEnvironmentMap;
            uniform bool useEnvironmentMap;     
            uniform float uRoughness;            
            uniform float uMetallic;            
        
            varying vec3 vPosition;      
            varying vec3 vNormal;    
        
            vec3 fresnelSchlick(float cosTheta, vec3 F0) {
                return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
            }
        
            float distributionGGX(vec3 N, vec3 H, float roughness) {
                float a = roughness * roughness;
                float a2 = a * a;
                float NdotH = max(dot(N, H), 0.0);
                float NdotH2 = NdotH * NdotH;
        
                float denom = (NdotH2 * (a2 - 1.0) + 1.0);
                return a2 / (3.14159265359 * denom * denom);
            }
        
            float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
                float NdotV = max(dot(N, V), 0.0);
                float NdotL = max(dot(N, L), 0.0);
                float r = (roughness + 1.0);
                float k = (r * r) / 8.0;
        
                float ggx1 = NdotV / (NdotV * (1.0 - k) + k);
                float ggx2 = NdotL / (NdotL * (1.0 - k) + k);
        
                return ggx1 * ggx2;
            }
        
            void main(void) {
                vec3 N = normalize(vNormal);               
                vec3 V = normalize(-vPosition);            
                vec3 L = normalize(uLightPos - vPosition); 
                vec3 H = normalize(V + L);                 
        
                float distance = length(uLightPos - vPosition);
                float attenuation = 1.0 / (distance * distance);
                float radiance = uLightPower * attenuation;
        
                vec3 F0 = mix(vec3(0.04), uSpecularColor, uMetallic);
                vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
                float NDF = distributionGGX(N, H, uRoughness);
        
                float G = geometrySmith(N, V, L, uRoughness);
        
                vec3 numerator = NDF * G * F;
                float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
                vec3 specular = numerator / denominator;
        
                vec3 kD = vec3(1.0) - F;
                kD *= 1.0 - uMetallic;
                vec3 diffuse = kD * uDiffuseColor / 3.14159265359;
                vec3 envColor = vec3(0.0);
                if (useEnvironmentMap) {
                    vec3 reflectedDir = reflect(-V, N);
                    reflectedDir = mix(reflectedDir, N, uRoughness);
                    envColor = textureCube(uEnvironmentMap, reflectedDir).rgb;
                }
                float NdotL = max(dot(N, L), 0.0);
                vec3 color = (diffuse + specular) * radiance * NdotL + envColor * uAmbient;
        
                gl_FragColor = vec4(color, 1.0);
            }
        </script>
        
    

    <!-- Fragment shader: normal -->
    <script id="shader-fs1-2" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vPosition;             // Vertex position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 1-2
            vec3 normalizedNormal = normalize(vNormal);
            gl_FragColor = vec4(abs(normalizedNormal), 1.0);
        }

    </script>

    <!-- Fragment shader: lighting direction -->
    <script id="shader-fs1-3" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 uLightPos;             // Light position in camera space

        varying vec3 vPosition;             // Fragment position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 1-3
            vec3 lightDir = normalize(uLightPos - vPosition);
            gl_FragColor = vec4(abs(lightDir), 1.0);
        }
    </script>

    <!-- Fragment shader: diffuse model -->
    <script id="shader-fs2" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 uLightPos;             // Light position in camera space
        uniform float uLightPower;          // Light power
        uniform vec3 uDiffuseColor;         // Diffuse color
        uniform float uAmbient;             // Ambient

        varying vec3 vPosition;             // Fragment position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 2
            vec3 lightDirection = uLightPos - vPosition;
            float lightDistance = length(lightDirection);
            vec3 normalizedLightDir = normalize(lightDirection);
            vec3 normalizedNormal = normalize(vNormal);

            float I = uLightPower / (pow(lightDistance, 2.0) / 5.0 + 5.0);
            float diffuse = max(dot(normalizedNormal, normalizedLightDir), 0.0);
            vec3 diffuseColor = uDiffuseColor * (I * diffuse + uAmbient);

            gl_FragColor = vec4(diffuseColor, 1.0);
        }
    </script>

    <!-- Fragment shader: Phong model -->
    <script id="shader-fs3-1" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 uLightPos;             // Light position in camera space
        uniform float uLightPower;          // Light power
        uniform vec3 uDiffuseColor;         // Diffuse color
        uniform vec3 uSpecularColor;
        uniform float uExponent;            // Phong exponent
        uniform float uAmbient;             // Ambient

        varying vec3 vPosition;             // Fragment position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 3-1
            vec3 lightDirection = uLightPos - vPosition;
            float lightDistance = length(lightDirection);
            vec3 normalizedLightDir = normalize(lightDirection);
            vec3 normalizedNormal = normalize(vNormal);
            vec3 viewDirection = normalize(-vPosition);

            float I = uLightPower / (pow(lightDistance, 2.0) / 5.0 + 5.0);

            float diffuse = max(dot(normalizedNormal, normalizedLightDir), 0.0);
            vec3 diffuseColor = uDiffuseColor * (I * diffuse + uAmbient);

            vec3 reflectionDirection = reflect(-normalizedLightDir, normalizedNormal);

            float specular = 0.0;
            if (diffuse > 0.0) {
                specular = pow(max(dot(viewDirection, reflectionDirection), 0.0), uExponent);
            }

            vec3 specularColor = uSpecularColor * I * specular;
            vec3 fragColor = diffuseColor + specularColor;
            gl_FragColor = vec4(fragColor, 1.0);

        }
    </script>

    <!-- Fragment shader: Blinn-Phong model -->
    <script id="shader-fs3-2" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 uLightPos;             // Light position in camera space
        uniform float uLightPower;          // Light power
        uniform vec3 uDiffuseColor;         // Diffuse color
        uniform vec3 uSpecularColor;
        uniform float uExponent;            // Blinn-Phong exponent
        uniform float uAmbient;             // Ambient

        varying vec3 vPosition;             // Fragment position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 3-2
            vec3 lightDirection = uLightPos - vPosition;
            float lightDistance = length(lightDirection);
            vec3 normalizedLightDir = normalize(lightDirection);

            vec3 normalizedNormal = normalize(vNormal);
            vec3 viewDirection = normalize(-vPosition);

            float I = uLightPower / (pow(lightDistance, 2.0) / 5.0 + 5.0);

            float diffuse = max(dot(normalizedNormal, normalizedLightDir), 0.0);
            vec3 diffuseColor = uDiffuseColor * (I * diffuse + uAmbient);

            vec3 halfVector = normalize(normalizedLightDir + viewDirection);

            float specular = 0.0;
            if (diffuse > 0.0) {
                specular = pow(max(dot(normalizedNormal, halfVector), 0.0), uExponent);
            }
            vec3 specularColor = uSpecularColor * I * specular;

            vec3 fragColor = diffuseColor + specularColor;

            gl_FragColor = vec4(fragColor, 1.0);

        }
    </script>

    <!-- Fragment shader: microfacet model -->
    <script id="shader-fs4" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 uLightPos;             // Light position in camera space
        uniform float uLightPower;          // Light power
        uniform vec3 uDiffuseColor;         // Diffuse color
        uniform vec3 uSpecularColor;
        uniform float uBeta;                // Roughness
        uniform float uIOR;                 // Index of refraction
        uniform float uAmbient;             // Ambient

        varying vec3 vPosition;             // Fragment position (camera space)
        varying vec3 vNormal;               // Fragment normal (camera space)

        void main(void) {
            // Dummy variable to ensure the use of all vertex attributes.
            vec4 zero = vec4(vPosition + vNormal - vPosition - vNormal, 0.0);

            // Task 4
            vec3 lightDirection = uLightPos - vPosition;
            float lightDistance = length(lightDirection);
            vec3 normalizedLightDir = normalize(lightDirection);

            vec3 normalizedNormal = normalize(vNormal);
            vec3 viewDirection = normalize(-vPosition);

            float I = uLightPower / (pow(lightDistance, 2.0) / 5.0 + 5.0);
            vec3 halfVector = normalize(normalizedLightDir + viewDirection);

            //Diffuse term
            float diffuse = max(dot(normalizedNormal, normalizedLightDir), 0.0);
            vec3 diffuseColor = uDiffuseColor * (I * diffuse + uAmbient);

            //Fresnel Factor
            float c = dot(normalizedLightDir, halfVector);
            float g = sqrt(uIOR * uIOR - 1.0 + c * c);
            float fresnel = 0.5 * pow((g - c) / (g + c), 2.0) * (1.0 + pow((c * (g + c) - 1.0) / (c * (g - c) + 1.0), 2.0));

            // Normal Distribution
            float cosThetaH = dot(normalizedNormal, halfVector);
            float tan2ThetaH = (1.0 / (cosThetaH * cosThetaH)) - 1.0;
            float D = (uBeta * uBeta) / (3.14159265359 * pow(cosThetaH, 4.0) * pow(uBeta * uBeta + tan2ThetaH, 2.0));

            // Geometry Term G
            float cosThetaI = dot(normalizedNormal, normalizedLightDir);
            float tan2ThetaI = (1.0 / (cosThetaI * cosThetaI)) - 1.0;
            float G1_i = 2.0 / (1.0 + sqrt(1.0 + uBeta * uBeta * tan2ThetaI));

            float cosThetaO = dot(normalizedNormal, viewDirection);
            float tan2ThetaO = (1.0 / (cosThetaO * cosThetaO)) - 1.0;
            float G1_o = 2.0 / (1.0 + sqrt(1.0 + uBeta * uBeta * tan2ThetaO));

            float G = G1_i * G1_o;

            vec3 specularColor = uSpecularColor * I * fresnel * D * G / (4.0 * cosThetaI * cosThetaO);
            vec3 fragColor = diffuseColor + specularColor;
            gl_FragColor = vec4(fragColor, 1.0);

        }
    </script>
</head>


<!-- HTML contents -->
<body>
<h1>CS112 Final Project - Advanced Shading</h1>
<p>
    Group member: <br>
</p>

<div class="droplist">
        <span>
            Object:
            <select onchange="changeActiveMesh(this);">
              <option value="0" selected="selected">Utah teapot</option>
              <option value="1">Stanford bunny</option>
              <option value="2">Rock</option>
              <option value="3">Sphere</option>
            </select>
        </span>
    <span style="margin-left:30px">
            Resolution:
            <select onchange="changeResolution(this);">
              <option value="0">640x360</option>
              <option value="1" selected="selected">800x450</option>
              <option value="2">960x540</option>
            </select>
        </span>

    <table>
        <tr>
            <td width="200px"><input type="checkbox" onchange="changeAnimatedState(this.checked);">Animated object</td>
            <td>
                <input id="sliderBar" type="range" min="1" max="36" value="6" onchange="updateSlider(this.value);" disabled>
                (<span id="sliderAmount">60</span>&deg;/s)
            </td>
        </tr>

    </table>
</div>


<div style="margin-top:10px">
    <canvas id="canvas0" style="border:none;" width="800" height="450"></canvas>
</div>

<div class="panel">
    <p>Light Source Parameters</p>
    <table>
        <tr>
            <td colspan="2"><input type="checkbox" onchange="changeShowLightState(this.checked);">Draw light source (as a point)</td>
        </tr>
        <tr>
            <td width="200px"><input type="checkbox" onchange="changeAnimatedLightState(this.checked);">Animated light</td>
            <td>
                <input id="sliderBarLight" type="range" min="1" max="36" value="6" onchange="updateSliderLight(this.value);" disabled>
                (<span id="sliderAmountLight">60</span>&deg;/s)
            </td>
        </tr>
        <tr>
            <td>Light power</td>
            <td>
                <input id="sliderBar_LightPower" type="range" min="1" max="20" value="10" onchange="updateSlider_LightPower(this.value);">
                (<span id="sliderAmount_LightPower">5</span>)
            </td>
        </tr>
    </table>
</div>

<div class="panel" style="margin-left:10px">
    <p>Shading Parameters (Common)</p>
    <table>
        <tr>
            <td width="200px">Shader</td>
            <td>
                <select onchange="changeActiveShader(this);">
                    <option value="0" selected="selected">Default: White</option>
                    <option value="8">Environment map</option>
                    <option value="9">Texture: Metal</option>
                    <option value="1">Texture: Matte Porcelain </option>
                    <option value="2">Normal</option>
                    <option value="3">Lighting Dir.</option>
                    <option value="4">Diffuse Reflectance Model</option>
                    <option value="5">Phong Reflectance Model</option>
                    <option value="6">Blinn-Phong Reflectance Model</option>
                    <option value="7">Microfacet Reflectance Model</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>Diffuse Color</td>
            <td>
                <input type="text" id="colorPicker"> (<span id="colorText">#1f75fe</span>)
            </td>
        </tr>
        <tr>
            <td>Specular Color</td>
            <td>
                <!-- Extra credit -->
                <input type="text" id="specularColorPicker"> (<span id="specularColorText">#ffffff</span>)
            </td>
        </tr>
        <tr>
            <td>Ambient</td>
            <td>
                <input type="range" min="0" max="50" value="10" onchange="updateSlider_Ambient(this.value);">
                (<span id="sliderAmount_Ambient">0.1</span>)
            </td>
        </tr>

        <tr class="phong-panel" style="display:none">
            <td colspan="2"><hr><p>Shading Parameters (Phong)</p></td>
        </tr>
        <tr class="phong-panel" style="display:none">
            <td>Exponent</td>
            <td>
                <input type="range" min="1" max="40" value="10" onchange="updateSlider_PhongExp(this.value);">
                (<span id="sliderAmount_PhongExp">50</span>)
            </td>
        </tr>

        <tr class="blinn-phong-panel" style="display:none">
            <td colspan="2"><hr><p>Shading Parameters (Blinn-Phong)</p></td>
        </tr>
        <tr class="blinn-phong-panel" style="display:none">
            <td>Exponent</td>
            <td>
                <input type="range" min="1" max="40" value="10" onchange="updateSlider_BlinnPhongExp(this.value);">
                (<span id="sliderAmount_BlinnPhongExp">50</span>)
            </td>
        </tr>

        <tr class="microfacet-panel" style="display:none">
            <td colspan="2"><hr><p>Shading Parameters (Microfacet)</p></td>
        </tr>
        <tr class="microfacet-panel" style="display:none">
            <td>Index of Refraction</td>
            <td>
                <input id="sliderBar_MicrofacetIOR" type="range" min="20" max="100" value="50" onchange="updateSlider_MicrofacetIOR(this.value);">
                (<span id="sliderAmount_MicrofacetIOR">5.0</span>)
            </td>
        </tr>
        <tr class="microfacet-panel" style="display:none">
            <td>Beta</td>
            <td>
                <input id="sliderBar_MicrofacetBeta" type="range" min="5" max="50" value="20" onchange="updateSlider_MicrofacetBeta(this.value);">
                (<span id="sliderAmount_MicrofacetBeta">0.2</span>)
            </td>
        </tr>
    </table>
</div>
<div style="clear:left"></div>
</body>

</html>
